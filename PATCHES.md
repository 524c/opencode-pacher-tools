# OpenCode Patches - LLM Regeneration Recipe

This document serves as a **comprehensive instruction manual** for LLM agents to understand, regenerate, and validate patches for OpenCode.

---

## Patch Philosophy

**Patches are concept-based modifications**, not static code diffs. When OpenCode's structure changes, patches must be regenerated by applying the same **abstract concept** to the new codebase. This document provides complete instructions for:

1. Understanding what each patch does (problem + solution)
2. Implementing the patch (strategy + detailed instructions)
3. Regenerating the patch (step-by-step guide with code examples)
4. Validating the patch (testing checklist)

**Key Principle**: Follow the concept, not the code. OpenCode changes, but the problems patches solve remain the same.

---

## Patch Categories

**All patches are independent** - no forced dependencies between patches. Apply any combination you need.

### 1. Conversation & Rules Preservation (2 patches)
- `agents-md-enforcement.patch` - Core mechanism for rules preservation
- `summarization-enhancement-p0.patch` - Reduces token waste, improves summary quality

**Conceptual relationship**: P0 enhances agents-md-enforcement by improving summarization quality, but can be applied independently.

### 2. Performance & Reliability (2 patches)
- `lsp-retry-mechanism.patch` - Auto-retry failed LSP servers
- `storage-migration-safety.patch` - Transactional database migrations with rollback

### 3. Configuration & Flexibility (1 patch)
- `provider-blacklist-config.patch` - Configurable model blacklist via opencode.json

### 4. Developer Experience (1 patch)
- `commit-hash-footer.patch` - Display version/commit hash in TUI footer

---

## agents-md-enforcement.patch

### üéØ Problem & Solution

**Problem:**
- OpenCode loads custom agent instructions from `AGENTS.md` and injects them as system prompts
- During long conversations, OpenCode summarizes old messages to save context space
- System prompts are **discarded** during summarization
- Result: **Agents stop following rules** after conversation summarization cycles

**Solution:**
- Move AGENTS.md from system prompts to conversation messages
- Pin rules messages so they survive summarization
- Inject rules on first user message instead of system prompt
- Preserve pinned messages when filtering summarized conversations

**Files Modified:**
- `packages/opencode/src/session/message-v2.ts` - Defines RulesPart message type
- `packages/opencode/src/session/prompt.ts` - Injects rules as conversation messages

---

### üìê Implementation Strategy

The patch modifies OpenCode's message system in **six conceptual areas**:

#### 1. Create New Message Part Type for Rules

**Concept:** Define a specialized message part that stores agent rules with metadata.

**Required fields:**
- `type`: Identifier for this part type ("rules")
- `rules`: The actual rule text content
- `source`: Where rules came from (e.g., "AGENTS.md")
- `pinned`: Boolean flag indicating this message survives summarization
- `hash`: Content hash for tracking rule changes

**Location:** `packages/opencode/src/session/message-v2.ts` (message part type definitions)

#### 2. Register Rules Part in Message System

**Concept:** Add the new rules part type to the message system's type union.

**Location:** `packages/opencode/src/session/message-v2.ts` (Part union type definition)

#### 3. Convert Rules Parts for AI Model Consumption

**Concept:** When converting messages for the AI model, transform rules parts into text parts.

**Location:** `packages/opencode/src/session/message-v2.ts` (message-to-model conversion logic)

**Logic:** `if (part.type === "rules") return [{ type: "text", text: part.rules }]`

#### 4. Preserve Pinned Rules During Summarization

**Concept:** Modify the summarization filter to extract and preserve pinned rule messages.

**Location:** `packages/opencode/src/session/message-v2.ts` - `filterSummarized()` function

**Current behavior:** Returns only messages after the last summary point

**New behavior:**
1. Find messages before summary containing pinned rules
2. Return: `[pinned messages] + [messages after summary]`

#### 5. Disable System Prompt Injection

**Concept:** Stop injecting AGENTS.md via system prompts since it won't survive summarization.

**Location:** `packages/opencode/src/session/prompt.ts` (system prompt construction)

#### 6. Inject Rules on First User Message

**Concept:** On the first user message of a session, prepend rules as a RulesPart.

**Location:** `packages/opencode/src/session/prompt.ts` - `createUserMessage()` or equivalent

---

### üîß Detailed Implementation Instructions

#### Step 1: Add RulesPart Type Definition

**File:** `packages/opencode/src/session/message-v2.ts`

**Location:** After existing part type definitions (TextPart, FilePart, etc.)

**Code:**
```typescript
// PATCH: agents-md-enforcement @ OpenCode v0.15.7
// Define RulesPart message type for pinned conversation rules
export const RulesPart = PartBase.extend({
  type: z.literal("rules"),
  rules: z.string(),
  source: z.string(),
  pinned: z.boolean(),
  hash: z.string(),
})

export type RulesPart = z.infer<typeof RulesPart>
```

#### Step 2: Add RulesPart to Part Union

**File:** `packages/opencode/src/session/message-v2.ts`

**Location:** Part discriminatedUnion definition

**Find:**
```typescript
export const Part = z.discriminatedUnion("type", [
  TextPart,
  FilePart,
  ToolPart,
  // ... other parts
])
```

**Add RulesPart to array:**
```typescript
export const Part = z.discriminatedUnion("type", [
  TextPart,
  FilePart,
  ToolPart,
  RulesPart,  // <-- ADD THIS
  // ... other parts
])
```

#### Step 3: Add Rules-to-Text Conversion

**File:** `packages/opencode/src/session/message-v2.ts`

**Location:** Message-to-model conversion function (where parts are converted for AI)

**Find:** Function that converts parts to AI-compatible format (look for `toModel()` or similar)

**Add:**
```typescript
// PATCH: agents-md-enforcement @ OpenCode v0.15.7
// Convert rules parts to text for AI consumption
if (part.type === "rules") {
  return [{ type: "text", text: part.rules }]
}
```

#### Step 4: Preserve Pinned Rules in filterSummarized

**File:** `packages/opencode/src/session/message-v2.ts`

**Function:** `filterSummarized()`

**Find:**
```typescript
export function filterSummarized(msgs: MessageV2.WithParts[]) {
  const i = msgs.findLastIndex((m) => m.info.role === "assistant" && !!m.info.summary)
  if (i === -1) return msgs.slice()
  return msgs.slice(i)
}
```

**Replace with:**
```typescript
// PATCH: agents-md-enforcement @ OpenCode v0.15.7
// Preserve pinned rules messages during summarization
export function filterSummarized(msgs: MessageV2.WithParts[]) {
  const i = msgs.findLastIndex((m) => m.info.role === "assistant" && !!m.info.summary)
  if (i === -1) return msgs.slice()
  
  // Extract messages with pinned rules BEFORE summary
  const pinnedRulesMessages = msgs
    .slice(0, i)
    .filter((msg) => msg.parts.some((part) => part.type === "rules" && part.pinned))
  
  // Return pinned rules + messages after summary
  return [...pinnedRulesMessages, ...msgs.slice(i)]
}
```

#### Step 5: Disable System Prompt Injection

**File:** `packages/opencode/src/session/prompt.ts`

**Location:** System prompt construction (where `SystemPrompt.custom()` is called)

**Find:**
```typescript
system.push(...(await SystemPrompt.environment()))
system.push(...(await SystemPrompt.custom()))  // <-- THIS LINE
```

**Comment out:**
```typescript
system.push(...(await SystemPrompt.environment()))
// PATCH: agents-md-enforcement @ OpenCode v0.15.7
// Disable system prompt injection for AGENTS.md (moved to conversation-based injection)
// This ensures rules remain visible in conversation context through summarization cycles.
// The RulesPart mechanism injects AGENTS.md as a pinned conversation message instead.
// system.push(...(await SystemPrompt.custom()))
```

#### Step 6: Inject Rules on First User Message

**File:** `packages/opencode/src/session/prompt.ts`

**Function:** `createUserMessage()` or equivalent message creation function

**Location:** After parts are created, before Plugin.trigger() is called

**Add:**
```typescript
// PATCH: agents-md-enforcement @ OpenCode v0.15.7 (updated)
// Inject RulesPart on first user message to preserve rules through summarization
const existingMessages = await Session.messages(input.sessionID)
const isFirstMessage = existingMessages.filter((m) => m.info.role === "user").length === 0

if (isFirstMessage) {
  const customPrompts = await SystemPrompt.custom()
  if (customPrompts.length > 0) {
    const rulesText = customPrompts.join("\n\n---\n\n")
    const hash = Bun.hash(rulesText).toString()

    // Prepend RulesPart at the beginning
    parts.unshift({
      id: Identifier.ascending("part"),
      messageID: info.id,
      sessionID: input.sessionID,
      type: "rules",
      rules: rulesText,
      source: "AGENTS.md",
      pinned: true,
      hash,
    })
  }
}
```

#### Step 6b: Detect Agent Switches Reliably

**File:** `packages/opencode/src/session/prompt.ts`

**Function:** Same as Step 6 (message creation function)

**Location:** After isFirstMessage check, alongside rules injection logic

**Concept:** Detect when the user switches agents to trigger rules re-injection, ensuring agent-specific rules are applied immediately.

**Why This Matters:**
- OpenCode allows multiple agents (e.g., `coder`, `k8s`, `diagnostic`)
- Each agent can have custom rules in AGENTS.md
- When switching agents, new agent-specific rules must be injected
- Original approach checked for `AgentPart` in input (only detects explicit `@agent-name` syntax)
- **Problem:** Misses agent switches via UI dropdown or implicit switching
- **Solution:** Compare previous assistant message's `mode` field with current agent

**Original Approach (Unreliable):**
```typescript
// Only detects explicit @agent-name syntax
const agentSwitch = input.parts?.find((p) => p.type === "agent")
```

**New Approach (Reliable):**
```typescript
// PATCH: agents-md-enforcement @ OpenCode v0.15.7 (updated)
// Detect agent switches by comparing previous mode with current agent
// This catches ALL agent switches (UI dropdown, implicit, explicit)
const lastAgentMode = existingMessages
  .slice()
  .reverse()
  .find((m) => m.info.role === "assistant")
  ?.info.mode

// Agent switch detected if previous mode differs from current agent
const agentSwitch = lastAgentMode && lastAgentMode !== (input.agent ?? "build")
```

**Why This Works Better:**
- `msg.info.mode` tracks which agent sent each message
- Vanilla OpenCode already uses this for agent tracking
- Compares last assistant's agent with current input agent
- Detects switches regardless of how user initiated them:
  - UI dropdown: mode changes without AgentPart
  - Explicit `@agent-name`: mode changes AND AgentPart present
  - Implicit delegation: mode changes via agent handoff

**Implementation Details:**
1. Find last assistant message in conversation
2. Extract its `info.mode` field (agent identifier)
3. Compare with current `input.agent` (defaults to "build")
4. If different ‚Üí agent switch detected ‚Üí re-inject rules

**Edge Cases Handled:**
- First message: no previous mode ‚Üí no agent switch
- Same agent: mode matches current ‚Üí no re-injection
- Explicit switch: AgentPart present ‚Üí still detected via mode comparison
- UI dropdown: no AgentPart ‚Üí detected via mode comparison

This approach aligns with vanilla OpenCode's agent tracking mechanism and is more robust than checking for AgentPart presence.

---

### üîç How to Regenerate This Patch

#### Analysis Phase

```bash
# Navigate to OpenCode submodule
cd opencode

# Check message type definitions
grep -n "export const.*Part.*=" packages/opencode/src/session/message-v2.ts

# Check Part union definition
grep -n "export const Part = z" packages/opencode/src/session/message-v2.ts

# Check filterSummarized function
grep -n "filterSummarized" packages/opencode/src/session/message-v2.ts

# Check SystemPrompt.custom usage
grep -n "SystemPrompt.custom" packages/opencode/src/session/prompt.ts

# Check user message creation
grep -n "createUserMessage\|async function.*message" packages/opencode/src/session/prompt.ts
```

#### Implementation Phase

1. Add RulesPart definition after existing part types
2. Add RulesPart to Part union
3. Add rules-to-text conversion in message processing
4. Modify filterSummarized to preserve pinned messages
5. Comment out SystemPrompt.custom() in system prompt construction
6. Add rules injection logic in first user message creation

#### Patch Generation

```bash
cd opencode
git add -A
git diff --cached > ../patches/agents-md-enforcement.patch
```

#### Testing

```bash
cd opencode
git reset --hard
git apply --check ../patches/agents-md-enforcement.patch
git apply ../patches/agents-md-enforcement.patch
bun install
bun run build:macos-arm64
```

---

### üß™ Validation Checklist

After regenerating the patch, verify:

- [ ] RulesPart type is defined with all required fields (type, rules, source, pinned, hash)
- [ ] RulesPart is added to Part union type
- [ ] Rules parts are converted to text for AI model consumption
- [ ] filterSummarized preserves pinned rule messages
- [ ] SystemPrompt.custom() is disabled with explanation comment
- [ ] Rules are injected on first user message only
- [ ] Agent switch detection uses `msg.info.mode` comparison (not AgentPart)
- [ ] Agent detection compares last assistant mode with current input agent
- [ ] Patch applies cleanly with `git apply --check`
- [ ] OpenCode builds successfully after patch application
- [ ] Test conversation: rules persist after summarization
- [ ] Test long conversation: AGENTS.md rules remain visible after multiple summarization cycles
- [ ] Test agent switching: rules re-injected when switching agents (via UI dropdown or explicit)

---

## commit-hash-footer.patch

### üéØ Problem & Solution

**Problem:**
- OpenCode TUI footer displays only "opencode dev" or "opencode vX.Y.Z"
- No indication of which commit/build is running
- Difficult to identify custom builds or specific commits
- "dev" text appears even in release builds, causing confusion

**Solution:**
- Add version identifier to TUI footer display
- Pass build mode from build system to control version display format
- Dynamic version display based on `OPENCODE_BUILD_MODE`:
  - **Release mode**: `opencode v0.15.4 [524c]` (no "dev", shows release tag)
  - **Commit mode**: `opencode dev abc1234 [524c]` (with "dev", shows commit hash)
- Hardcoded custom identifier `[524c]` always appears to mark custom builds

**Files Modified:**
- `packages/tui/cmd/opencode/main.go` - Declares CommitHash and BuildMode variables
- `packages/tui/internal/app/app.go` - Stores CommitHash and BuildMode in app state
- `packages/tui/internal/components/status/status.go` - Displays dynamic version in footer

---

### üìê Implementation Strategy

The patch modifies OpenCode TUI in **four conceptual areas**:

#### 1. Add CommitHash Variable to TUI Entry Point

**Concept:** Declare a build-time variable that can be set during compilation.

**Location:** `packages/tui/cmd/opencode/main.go` (top-level variables)

**Pattern:** `var CommitHash = ""`

**Purpose:** Allows Go linker to inject commit hash via `-ldflags`

#### 2. Pass CommitHash to App Constructor

**Concept:** Thread commit hash through the application initialization.

**Location:** `packages/tui/cmd/opencode/main.go` - `main()` function (where `app.New()` is called)

#### 3. Store CommitHash in App State

**Concept:** Add commit hash field to application state for access throughout TUI.

**Locations:**
- `packages/tui/internal/app/app.go` - App struct (add `CommitHash string` field)
- `packages/tui/internal/app/app.go` - `New()` function (add `commitHash` parameter)

#### 4. Display CommitHash with Dynamic Version Logic

**Concept:** Modify the logo/footer display to intelligently show version based on build mode.

**Location:** `packages/tui/internal/components/status/status.go` - `logo()` function

**Logic:**
- If `CommitHash` starts with "v" ‚Üí Release mode (show tag without "dev")
- If `CommitHash` is hash ‚Üí Commit mode (show "dev" + hash)
- Always append `[524c]` custom identifier

---

### üîß Detailed Implementation Instructions

#### Step 1: Add CommitHash Variable

**File:** `packages/tui/cmd/opencode/main.go`

**Location:** Top-level variables (alongside Version)

**Find:**
```go
var Version = "dev"
```

**Add after:**
```go
var Version = "dev"
// PATCH: commit-hash-footer @ OpenCode v0.15.7
// CommitHash is injected at build time via -ldflags to display version identifier
var CommitHash = ""
```

#### Step 2: Pass CommitHash to App Constructor

**File:** `packages/tui/cmd/opencode/main.go`

**Function:** `main()`

**Find:** Where `app.New()` is called

**Add before `app.New()` call:**
```go
// PATCH: commit-hash-footer @ OpenCode v0.15.7
// Prepare commit hash with fallback for version display
commitHash := CommitHash
if commitHash == "" {
    commitHash = "unknown"
}
```

**Update `app.New()` call:**
```go
app_, err := app.New(ctx, version, commitHash, project, path, agents, httpClient, model, prompt, agent, sessionID)
```

#### Step 3: Update App Struct and Constructor

**File:** `packages/tui/internal/app/app.go`

**Struct:** `App`

**Find:**
```go
type App struct {
    Version           string
    // ... other fields
}
```

**Add field:**
```go
type App struct {
    Version           string
    // PATCH: commit-hash-footer @ OpenCode v0.15.7
    // CommitHash stores version identifier for footer display
    CommitHash        string
    // ... other fields
}
```

**Function:** `New()`

**Find:**
```go
func New(
    ctx context.Context,
    version string,
    project *opencode.Project,
    // ... other params
) (*App, error) {
```

**Add parameter:**
```go
func New(
    ctx context.Context,
    version string,
    // PATCH: commit-hash-footer @ OpenCode v0.15.7
    commitHash string,
    project *opencode.Project,
    // ... other params
) (*App, error) {
```

**Find App initialization:**
```go
app := &App{
    Version:           version,
    // ... other fields
}
```

**Add field assignment:**
```go
app := &App{
    Version:           version,
    // PATCH: commit-hash-footer @ OpenCode v0.15.7
    CommitHash:        commitHash,
    // ... other fields
}
```

#### Step 4: Update Footer Display with Dynamic Version Logic

**File:** `packages/tui/internal/components/status/status.go`

**Function:** `logo()`

**Find:**
```go
open := base("open")
code := emphasis("code")
version := base(" " + m.app.Version)
```

**Replace version line with:**
```go
open := base("open")
code := emphasis("code")

// PATCH: commit-hash-footer @ OpenCode v0.15.7
// Build version string dynamically based on CommitHash value
versionText := ""

if m.app.CommitHash != "" && m.app.CommitHash != "unknown" {
    // Check if CommitHash is a release tag (starts with "v")
    if strings.HasPrefix(m.app.CommitHash, "v") {
        // Release mode: show tag without "dev"
        // Example: "opencode v0.15.4 [524c]"
        versionText = " " + m.app.CommitHash
    } else {
        // Commit mode: show "dev" with commit hash
        // Example: "opencode dev abc1234 [524c]"
        versionText = " " + m.app.Version + " " + m.app.CommitHash
    }
} else {
    // Fallback: no commit hash available
    // Example: "opencode dev [524c]"
    versionText = " " + m.app.Version
}

// Always append [524c] custom identifier
versionText += " [524c]"

version := base(versionText)
```

---

### üîç How to Regenerate This Patch

#### Analysis Phase

```bash
cd opencode

# Identify TUI entry point
ls packages/tui/cmd/opencode/main.go

# Identify app initialization
ls packages/tui/internal/app/app.go

# Identify status component
ls packages/tui/internal/components/status/status.go

# Search for Version variable
rg "var Version" packages/tui --type go

# Search for app.New function
rg "func New\(" packages/tui/internal/app --type go

# Search for logo function
rg "func.*logo\(\)" packages/tui/internal/components/status --type go
```

#### Implementation Phase

1. Add `CommitHash` variable after `Version` in main.go
2. Add commit hash preparation logic before `app.New()` call
3. Add `commitHash` parameter to `app.New()` call
4. Add `CommitHash` field to App struct
5. Add `commitHash` parameter to `New()` function signature
6. Assign `CommitHash` in App initialization
7. Replace version display logic in `logo()` with dynamic version display

#### Patch Generation

```bash
cd opencode
git add packages/tui/cmd/opencode/main.go \
        packages/tui/internal/app/app.go \
        packages/tui/internal/components/status/status.go
git diff --cached > ../patches/commit-hash-footer.patch
```

#### Testing

```bash
cd opencode
git reset --hard
git apply --check ../patches/commit-hash-footer.patch
git apply ../patches/commit-hash-footer.patch
go build -C packages/tui/cmd/opencode
```

---

### üß™ Validation Checklist

After regenerating the patch, verify:

- [ ] CommitHash variable is declared in main.go
- [ ] CommitHash is passed to app.New() with fallback logic
- [ ] App struct contains CommitHash field
- [ ] app.New() accepts commitHash parameter
- [ ] CommitHash is assigned in app initialization
- [ ] logo() function uses dynamic version display logic
- [ ] Release builds show clean version tag without "dev" (e.g., `opencode v0.15.4 [524c]`)
- [ ] Commit builds show "dev" with commit hash (e.g., `opencode dev abc1234 [524c]`)
- [ ] Custom identifier `[524c]` always appears
- [ ] Patch applies cleanly with `git apply --check`
- [ ] TUI compiles successfully: `go build -C packages/tui/cmd/opencode`
- [ ] Test display in release mode: Footer shows `opencode vX.Y.Z [524c]` (no "dev")
- [ ] Test display in commit mode: Footer shows `opencode dev abc1234 [524c]` (with "dev")

---

## summarization-enhancement-p0.patch

### üéØ Problem & Solution

**Problem:**
- OpenCode's summarization calls `SystemPrompt.custom()` to inject AGENTS.md during summarization
- This is redundant: AGENTS.md is already preserved as RulesPart (via agents-md-enforcement.patch)
- Result: **~1500 tokens wasted per summarization**
- Summarization prompt (`summarize.txt`) is generic and unstructured
- Result: **Inconsistent summaries** that lose critical context (active agent, current tasks, next steps)

**Solution:**
- **Phase 1A: Remove AGENTS.md redundancy** - Disable AGENTS.md injection during summarization
- **Phase 1B: Structured summarization prompt** - Replace generic prompt with structured template
- Enforce consistent sections: "What We Did", "Current State", "Next Steps"

**Files Modified:**
- `packages/opencode/src/session/compaction.ts` - Disables AGENTS.md redundancy
- `packages/opencode/src/session/summarize.txt` - Structured summarization template

**Conceptual Dependency:** Works best with `agents-md-enforcement.patch` but applies independently. Without agents-md-enforcement, the AGENTS.md redundancy fix has no effect, but the structured summarization template still improves summary quality.

---

### üìê Implementation Strategy

The patch modifies OpenCode's summarization in **two conceptual areas**:

#### 1. Disable AGENTS.MD Redundancy During Summarization

**Concept:** Stop injecting AGENTS.md via system prompts during summarization since it's already preserved as RulesPart.

**Location:** `packages/opencode/src/session/compaction.ts` - `compact()` function (system prompt construction for summarization, around line 99)

**Current code:** `system.push(...(await SystemPrompt.custom()))`

**New code:** Comment out this line with explanation

**Why this works:**
- AGENTS.md is already preserved via RulesPart (agents-md-enforcement.patch)
- RulesPart messages are pinned and survive summarization
- No need to re-inject AGENTS.md into system prompts
- Saves ~1500 tokens per summarization cycle

#### 2. Structured Summarization Prompt

**Concept:** Replace generic summarization prompt with structured template that enforces consistent sections.

**Location:** `packages/opencode/src/session/summarize.txt`

**Replace entire content** with structured template that includes:
- Mandatory output format (What We Did, Current State, Next Steps)
- Length limits (max 15 lines total)
- Bullet point format enforcement
- Critical context preservation (active agent, working files, project context)

---

### üîß Detailed Implementation Instructions

#### Step 1: Disable AGENTS.md Injection in Compaction

**File:** `packages/opencode/src/session/compaction.ts`

**Function:** `compact()`

**Find:** (around line 99)
```typescript
system.push(...(await SystemPrompt.environment()))
system.push(...(await SystemPrompt.custom()))  // <-- THIS LINE
```

**Replace with:**
```typescript
system.push(...(await SystemPrompt.environment()))
// PATCH: summarization-enhancement-p0 @ OpenCode v0.15.7
// Disable AGENTS.md injection during summarization (already preserved as RulesPart)
// This eliminates ~1500 tokens of redundant content per summarization
// system.push(...(await SystemPrompt.custom()))
```

#### Step 2: Replace Summarization Template

**File:** `packages/opencode/src/session/summarize.txt`

**Replace entire file content with:**
```
You are summarizing a coding conversation to preserve critical context while reducing token count.

**CRITICAL RULES:**
- Be EXTREMELY CONCISE (max 15 lines total)
- Use bullet points, not prose
- Focus on FACTS, not descriptions
- Preserve EXACT file paths, function names, technical details
- NEVER lose current state information

**OUTPUT FORMAT (MANDATORY):**

## What We Did
- [List completed tasks - max 5 bullets]
- [Focus on actual changes made]

## Current State
- **Active Agent:** [agent name or "default"]
- **Working Files:** [exact file paths]
- **Project Context:** [brief project description]
- **Key Decisions:** [important choices made]

## Next Steps
- [What needs to be done - max 3 bullets]

**ENFORCE STRUCTURE:** Output MUST follow this format exactly. No additional sections.
```

---

### üîç How to Regenerate This Patch

#### Analysis Phase

```bash
cd opencode

# Check compaction logic
grep -n "SystemPrompt.custom" packages/opencode/src/session/compaction.ts

# Check summarization prompt location
ls packages/opencode/src/session/summarize.txt

# Verify RulesPart mechanism exists (prerequisite)
grep -n "RulesPart" packages/opencode/src/session/message-v2.ts
```

#### Implementation Phase

1. Find the `compact()` function in compaction.ts
2. Locate where `SystemPrompt.custom()` is called (around line 99)
3. Comment out the line with explanation
4. Add version marker comment
5. Replace entire content of `summarize.txt` with new structured template
6. Verify CRLF line endings if required by OpenCode
7. Verify markdown formatting is correct

#### Patch Generation

```bash
cd opencode
git add -A
git diff --cached > ../patches/summarization-enhancement-p0.patch
```

#### Testing

```bash
cd opencode
git reset --hard
# Apply this patch independently (no prerequisites required)
git apply --check ../patches/summarization-enhancement-p0.patch
git apply ../patches/summarization-enhancement-p0.patch
bun install
bun run build:macos-arm64

# Note: For full functionality, apply agents-md-enforcement.patch first
# But the patch applies cleanly without it
```

---

### üß™ Validation Checklist

After regenerating the patch, verify:

- [ ] `SystemPrompt.custom()` is commented out in compaction.ts with explanation
- [ ] Version marker comment is present
- [ ] `summarize.txt` has new structured template
- [ ] Template includes all mandatory sections (What We Did, Current State, Next Steps)
- [ ] Patch applies cleanly with `git apply --check` (no prerequisites required)
- [ ] OpenCode builds successfully after patch
- [ ] Test summarization: produces structured output with all sections
- [ ] Token count reduced (if agents-md-enforcement also applied): before ~3500, after ~2000 tokens
- [ ] Summary preserves critical context (files, agent, decisions)

---

## lsp-retry-mechanism.patch

### üéØ Problem & Solution

**Problem:**
- LSP servers that fail to initialize are permanently marked as "broken" for entire OpenCode session
- No retry mechanism - once failed, permanently disabled until restart
- Temporary issues (network glitches, resource constraints) result in permanent LSP unavailability
- Result: **Poor developer experience** and **unnecessary restarts**

**Solution:**
- **Add automatic retry mechanism** for failed LSP servers
- **Exponential backoff strategy**: 30s ‚Üí 1m ‚Üí 5m between retry attempts
- **Maximum retry limit**: 3 attempts before giving up
- **Track failure metadata**: count, timestamp, retry schedule
- **Automatic retry on next `getClients()` call** if retry window has elapsed

**Files Modified:**
- `packages/opencode/src/lsp/index.ts` - Adds retry logic with exponential backoff

---

### üìê Implementation Strategy

The patch modifies OpenCode's LSP management in **four conceptual areas**:

#### 1. Replace Simple Failure Tracking with Detailed Metadata

**Concept:** Track not just whether server is broken, but failure count, timestamps, and retry schedule.

**Location:** `packages/opencode/src/lsp/index.ts` (top-level data structure, after imports)

**Current:** `const broken = new Set<string>()`

**New:** `const broken = new Map<string, BrokenServer>()`

**Data structure:**
```typescript
interface BrokenServer {
  failureCount: number
  lastFailureTime: number  // Unix timestamp
  nextRetryTime: number    // Unix timestamp
}
```

#### 2. Add Retry Logic Functions

**Concept:** Implement helper functions to determine if server should be retried and how to update failure state.

**Location:** `packages/opencode/src/lsp/index.ts` (after `broken` data structure, before `getClients()` function)

**Functions:**
- `shouldRetryServer()`: Checks max retry limit and retry window
- `markServerFailed()`: Updates failure state with exponential backoff

#### 3. Update `getClients()` to Use Retry Logic

**Concept:** Modify LSP client filtering to allow retry of eligible broken servers.

**Location:** `packages/opencode/src/lsp/index.ts` - `getClients()` function (where broken servers are filtered, around line 56-58)

**Logic:** Check retry eligibility instead of permanent blocking

#### 4. Update Failure Marking After Connection Failure

**Concept:** When LSP connection fails, use new `markServerFailed()` function.

**Location:** `packages/opencode/src/lsp/index.ts` - `getClients()` function (where servers are added to broken set after failure, around line 80-85)

---

### üîß Detailed Implementation Instructions

#### Step 1: Replace Broken Set with Detailed Metadata Map

**File:** `packages/opencode/src/lsp/index.ts`

**Location:** Top-level data structures (after imports)

**Find:**
```typescript
const broken = new Set<string>()
```

**Replace with:**
```typescript
// PATCH: lsp-retry-mechanism @ OpenCode v0.15.7
// Replace Set with Map to track retry metadata per server
interface BrokenServer {
  failureCount: number
  lastFailureTime: number
  nextRetryTime: number
}

const broken = new Map<string, BrokenServer>()
```

#### Step 2: Add Retry Logic Helper Functions

**File:** `packages/opencode/src/lsp/index.ts`

**Location:** After `broken` data structure, before `getClients()` function

**Add:**
```typescript
// PATCH: lsp-retry-mechanism @ OpenCode v0.15.7
// Determine if a broken server should be retried based on retry schedule
function shouldRetryServer(serverInfo: BrokenServer): boolean {
  const now = Date.now()
  const maxRetries = 3
  
  // Give up after max retries
  if (serverInfo.failureCount >= maxRetries) {
    return false
  }
  
  // Check if retry window has elapsed
  return now >= serverInfo.nextRetryTime
}

// Mark server as failed and calculate next retry time with exponential backoff
function markServerFailed(serverId: string): void {
  const now = Date.now()
  const existing = broken.get(serverId)
  
  const failureCount = existing ? existing.failureCount + 1 : 1
  
  // Exponential backoff: 30s, 1m, 5m
  const backoffDelays = [30 * 1000, 60 * 1000, 5 * 60 * 1000]
  const delay = backoffDelays[Math.min(failureCount - 1, backoffDelays.length - 1)]
  
  broken.set(serverId, {
    failureCount,
    lastFailureTime: now,
    nextRetryTime: now + delay,
  })
}
```

#### Step 3: Update getClients() to Check Retry Eligibility

**File:** `packages/opencode/src/lsp/index.ts`

**Function:** `getClients()`

**Find:** (around line 56-58)
```typescript
if (broken.has(server.id)) continue
```

**Replace with:**
```typescript
// PATCH: lsp-retry-mechanism @ OpenCode v0.15.7
// Check if server should be retried instead of permanently blocking
const serverInfo = broken.get(server.id)
if (serverInfo) {
  if (!shouldRetryServer(serverInfo)) {
    // Still within failure window or max retries exceeded
    continue
  }
  // Retry window elapsed - remove from broken list to allow retry
  broken.delete(server.id)
}
```

#### Step 4: Update Failure Marking in Error Handler

**File:** `packages/opencode/src/lsp/index.ts`

**Function:** `getClients()`

**Find:** (around line 80-85)
```typescript
catch (err) {
  broken.add(server.id)
}
```

**Replace with:**
```typescript
catch (err) {
  // PATCH: lsp-retry-mechanism @ OpenCode v0.15.7
  // Use markServerFailed to schedule retry instead of permanent failure
  markServerFailed(server.id)
  log.exception(`LSP server '${server.id}' failed to start (attempt ${broken.get(server.id)?.failureCount ?? 1}/3)`, err)
}
```

---

### üîç How to Regenerate This Patch

#### Analysis Phase

```bash
cd opencode

# Check LSP index file
cat packages/opencode/src/lsp/index.ts | head -100

# Check broken server tracking
grep -n "broken.add\|broken.has" packages/opencode/src/lsp/index.ts

# Check getClients function
grep -n "export async function getClients" packages/opencode/src/lsp/index.ts -A 50
```

#### Implementation Phase

1. Replace `broken = new Set<string>()` with `broken = new Map<string, BrokenServer>()`
2. Add `BrokenServer` interface definition
3. Add `shouldRetryServer()` and `markServerFailed()` functions
4. Update `getClients()` to check retry eligibility
5. Replace `broken.add()` with `markServerFailed()` in error handler
6. Add version marker comments

#### Patch Generation

```bash
cd opencode
git add -A
git diff --cached > ../patches/lsp-retry-mechanism.patch
```

#### Testing

```bash
cd opencode
git reset --hard
git apply --check ../patches/lsp-retry-mechanism.patch
git apply ../patches/lsp-retry-mechanism.patch
bun install
bun run build:macos-arm64
```

---

### üß™ Validation Checklist

After regenerating the patch, verify:

- [ ] `BrokenServer` interface is defined with failureCount, lastFailureTime, nextRetryTime
- [ ] `broken` is changed from `Set<string>` to `Map<string, BrokenServer>`
- [ ] `shouldRetryServer()` function exists and checks max retries + retry window
- [ ] `markServerFailed()` function exists and implements exponential backoff
- [ ] `getClients()` checks `shouldRetryServer()` before filtering broken servers
- [ ] Error handler calls `markServerFailed()` instead of `broken.add()`
- [ ] Version marker comments present
- [ ] Patch applies cleanly with `git apply --check`
- [ ] OpenCode builds successfully after patch
- [ ] Test LSP failure: server retries automatically after backoff period
- [ ] Test max retries: server stops retrying after 3 failures
- [ ] Test successful retry: server works after temporary failure resolved

---

## storage-migration-safety.patch

### üéØ Problem & Solution

**Problem:**
- OpenCode storage migrations run once without rollback capability
- If migration fails mid-execution, storage can be left in corrupt state
- No backup mechanism before applying migrations
- Result: **Data corruption risk** and **unrecoverable migration failures**

**Solution:**
- **Add transactional migration** with backup/rollback capability
- **Create backup** before each migration step
- **Rollback on failure** to restore previous state
- **Cleanup backups** after successful migration
- **Sequential migration execution** (not parallel) for safety

**Files Modified:**
- `packages/opencode/src/storage/storage.ts` - Adds transactional migration with backup/rollback

---

### üìê Implementation Strategy

The patch modifies OpenCode's storage migration in **one conceptual area**:

#### Add Transactional Migration with Backup/Rollback

**Concept:** Wrap migration execution in backup/restore logic to enable safe rollback on failure.

**Location:** `packages/opencode/src/storage/storage.ts` - Migration execution logic (around line 150-200, where `loadMigrations()` results are processed)

**Current logic:**
```typescript
// Migrations run in parallel without backup
await Promise.all(migrations.map(async (migration) => {
  await migration.run()
}))
```

**New logic:**
- Sequential execution (not parallel)
- Backup per migration
- Automatic rollback on failure
- Cleanup after success
- Critical logging if rollback fails

---

### üîß Detailed Implementation Instructions

#### Step 1: Replace Parallel Execution with Sequential Transactional Migration

**File:** `packages/opencode/src/storage/storage.ts`

**Location:** Where migrations are executed (after `loadMigrations()`)

**Find:**
```typescript
await Promise.all(migrations.map(async (migration) => {
  await migration.run()
}))
```

**Replace with:**
```typescript
// PATCH: storage-migration-safety @ OpenCode v0.15.7
// Add transactional migration with backup/rollback capability
for (const migration of migrations) {
  const backupPath = `${storagePath}.backup-${migration.version}`
  
  try {
    // Create backup before migration
    if (fs.existsSync(storagePath)) {
      fs.copyFileSync(storagePath, backupPath)
    }
    
    // Execute migration
    await migration.run()
    
    // Cleanup backup after success
    if (fs.existsSync(backupPath)) {
      fs.unlinkSync(backupPath)
    }
    
  } catch (err) {
    // Rollback on failure
    log.error(`Migration ${migration.version} failed, rolling back...`)
    
    if (fs.existsSync(backupPath)) {
      fs.copyFileSync(backupPath, storagePath)
      fs.unlinkSync(backupPath)
      log.info(`Rolled back to pre-migration state`)
    } else {
      log.critical(`Rollback failed: backup not found for migration ${migration.version}`)
    }
    
    throw err  // Re-throw to prevent further migrations
  }
}
```

#### Step 2: Ensure fs Module is Imported

**File:** `packages/opencode/src/storage/storage.ts`

**Location:** Top of file (imports section)

**Check if `fs` is already imported. If not, add:**
```typescript
import fs from "fs"
```

---

### üîç How to Regenerate This Patch

#### Analysis Phase

```bash
cd opencode

# Check storage migration logic
grep -n "loadMigrations\|migration.run" packages/opencode/src/storage/storage.ts -A 10

# Check storage path variable
grep -n "storagePath" packages/opencode/src/storage/storage.ts

# Verify fs module is imported
grep -n "import.*fs" packages/opencode/src/storage/storage.ts
```

#### Implementation Phase

1. Locate where migrations are executed (after `loadMigrations()`)
2. Replace `Promise.all()` parallel execution with sequential `for` loop
3. Add backup creation before migration execution
4. Add rollback logic in `catch` block
5. Add cleanup logic after successful migration
6. Add version marker comments
7. Ensure `fs` module is imported (add if missing)

#### Patch Generation

```bash
cd opencode
git add -A
git diff --cached > ../patches/storage-migration-safety.patch
```

#### Testing

```bash
cd opencode
git reset --hard
git apply --check ../patches/storage-migration-safety.patch
git apply ../patches/storage-migration-safety.patch
bun install
bun run build:macos-arm64
```

---

### üß™ Validation Checklist

After regenerating the patch, verify:

- [ ] Migrations execute sequentially (not parallel)
- [ ] Backup is created before each migration
- [ ] Backup path includes migration version
- [ ] Rollback logic exists in catch block
- [ ] Rollback restores backup and deletes backup file
- [ ] Cleanup logic removes backup after successful migration
- [ ] Critical error logged if rollback fails
- [ ] Error is re-thrown to stop further migrations
- [ ] `fs` module is imported (add if needed)
- [ ] Version marker comments present
- [ ] Patch applies cleanly with `git apply --check`
- [ ] OpenCode builds successfully after patch
- [ ] Test migration: backup created, then removed after success
- [ ] Test failed migration: rollback restores previous state

---

## provider-blacklist-config.patch

### üéØ Problem & Solution

**Problem:**
- Model blacklist is hardcoded in `provider/provider.ts`
- Only 2 models blacklisted: `gpt-5-chat-latest` and `openrouter/openai/gpt-5-chat`
- No way to blacklist additional models without source code changes
- Result: **Inflexible model filtering** and **recompilation required** for blacklist updates

**Solution:**
- **Move blacklist to `opencode.json` configuration**
- **Add `modelBlacklist` config field** with provider-specific and global blacklist entries
- **Maintain backward compatibility** by keeping current hardcoded blacklist as default
- **Enable user customization** without recompilation

**Example configuration:**
```json
{
  "modelBlacklist": [
    { "model": "gpt-5-chat-latest" },
    { "provider": "openrouter", "model": "openai/gpt-5-chat" },
    { "provider": "anthropic", "model": "claude-2-experimental" }
  ]
}
```

**Files Modified:**
- `packages/opencode/src/config/config.ts` - Adds modelBlacklist configuration schema
- `packages/opencode/src/provider/provider.ts` - Uses configurable blacklist

---

### üìê Implementation Strategy

The patch modifies OpenCode in **two conceptual areas**:

#### 1. Add `modelBlacklist` Configuration Schema

**Concept:** Define configuration schema for model blacklist entries.

**Location:** `packages/opencode/src/config/config.ts` - Config schema definition (around line 550, after `lsp` field)

**Schema:**
- Array of blacklist entries
- Optional `provider` field (if omitted, applies to all providers)
- Required `model` field (the model ID to blacklist)

#### 2. Use Configurable Blacklist in Provider Filtering

**Concept:** Replace hardcoded blacklist check with configuration-based filtering.

**Location:** `packages/opencode/src/provider/provider.ts` - Provider loading logic (around line 355-370, where models are filtered)

**Logic:**
- Load configuration dynamically
- Default to current hardcoded behavior if not configured
- Filter models based on provider-specific or global blacklist

---

### üîß Detailed Implementation Instructions

#### Step 1: Add modelBlacklist to Config Schema

**File:** `packages/opencode/src/config/config.ts`

**Location:** Config schema definition (around line 550, after `lsp` field)

**Find:** (look for fields like `lsp`, `instructions`, `layout`)

**Add after similar field:**
```typescript
// PATCH: provider-blacklist-config @ OpenCode v0.15.7
// Add configurable model blacklist instead of hardcoded values
modelBlacklist: z
  .array(
    z.object({
      provider: z.string().optional().describe("Provider ID (if omitted, applies to all providers)"),
      model: z.string().describe("Model ID to blacklist"),
    }),
  )
  .optional()
  .describe("Models to exclude from provider listings"),
```

#### Step 2: Use Configurable Blacklist in Provider Filtering

**File:** `packages/opencode/src/provider/provider.ts`

**Location:** Provider loading logic (around line 355-370)

**Find:**
```typescript
.filter(
  ([modelID]) =>
    modelID !== "gpt-5-chat-latest" && !(providerID === "openrouter" && modelID === "openai/gpt-5-chat"),
)
```

**Replace with:**
```typescript
// PATCH: provider-blacklist-config @ OpenCode v0.15.7
// Use configurable model blacklist instead of hardcoded values
const config = await Config.get()
const blacklist = config.modelBlacklist ?? [
  // Default blacklist (maintains existing behavior if not configured)
  { model: "gpt-5-chat-latest" },
  { provider: "openrouter", model: "openai/gpt-5-chat" },
]

for (const [providerID, provider] of Object.entries(providers)) {
  const filteredModels = Object.fromEntries(
    Object.entries(provider.info.models)
      // Filter out blacklisted models
      .filter(([modelID]) => {
        return !blacklist.some(
          (entry) =>
            entry.model === modelID && (!entry.provider || entry.provider === providerID),
        )
      })
      // ... rest of filtering logic ...
  )
}
```

**Note:** The exact location and surrounding code may vary. Look for:
- Provider loop: `for (const [providerID, provider] of Object.entries(providers))`
- Model filtering: `.filter(([modelID]) => ...)`
- Hardcoded blacklist check: `modelID !== "gpt-5-chat-latest"`

---

### üîç How to Regenerate This Patch

#### Analysis Phase

```bash
cd opencode

# Check config schema
grep -n "instructions\|layout\|permission" packages/opencode/src/config/config.ts | head -20

# Check provider filtering logic
grep -n "gpt-5-chat-latest" packages/opencode/src/provider/provider.ts -B 5 -A 10

# Check Config.get() usage
grep -n "Config.get()" packages/opencode/src/provider/provider.ts
```

#### Implementation Phase

1. Locate config schema in config.ts (around line 550, after `lsp` field)
2. Add `modelBlacklist` field definition
3. Add version marker comment
4. Locate provider loading logic in provider.ts (around line 355)
5. Add `Config.get()` call before provider loop
6. Define `blacklist` with fallback to defaults
7. Replace hardcoded filter with `blacklist.some()` logic
8. Add version marker comment

#### Patch Generation

```bash
cd opencode
git add -A
git diff --cached > ../patches/provider-blacklist-config.patch
```

#### Testing

```bash
cd opencode
git reset --hard
git apply --check ../patches/provider-blacklist-config.patch
git apply ../patches/provider-blacklist-config.patch
bun install
bun run build:macos-arm64
```

---

### üß™ Validation Checklist

After regenerating the patch, verify:

- [ ] `modelBlacklist` field added to config schema
- [ ] Schema allows optional `provider` field
- [ ] Schema requires `model` field
- [ ] Config.get() called before provider loop
- [ ] `blacklist` variable defined with default fallback
- [ ] Filter logic checks both provider-specific and global entries
- [ ] Default blacklist matches current hardcoded behavior
- [ ] Version marker comments present
- [ ] Patch applies cleanly with `git apply --check`
- [ ] OpenCode builds successfully after patch
- [ ] Test default behavior: same models blacklisted as before
- [ ] Test custom config: additional models successfully blacklisted
- [ ] Test provider-specific: only affects specified provider
- [ ] Test global blacklist: affects all providers

---

## Patch Application Order

**All patches are independent** - they apply cleanly in any order.

**Recommended order for full functionality:**

1. `agents-md-enforcement.patch` - Core rules preservation mechanism
2. `summarization-enhancement-p0.patch` - Builds on agents-md (removes AGENTS.md redundancy)
3. Any other patches (truly independent)

**Why this order?**
- P0 removes AGENTS.md injection during summarization (only useful if agents-md-enforcement preserves it elsewhere)

**Can you apply them in different order?** Yes! Each patch applies independently. You'll just lose some synergy:
- P0 without agents-md-enforcement: Template works, but AGENTS.md redundancy fix has no effect

The `tools/apply-all-patches.ts` script respects the `enabled` flag in `patches.config.yaml` and applies patches in the recommended order.

---

## Version Tracking

**Current OpenCode Version:** v0.15.7  
**Patch Compatibility:** All patches validated against this version

**Key Information:**
- All patches include version markers (e.g., `// PATCH: name @ OpenCode v0.15.7`)
- Version markers track which OpenCode version patch was designed for
- Use version markers to identify sections needing review when OpenCode changes

---

## Future Patches

When creating new patches, document them here following this structure:

1. **Problem & Solution**: What problem does it solve? What changes does it make?
2. **Implementation Strategy**: High-level approach and key architectural decisions
3. **Detailed Implementation Instructions**: Step-by-step guide with concrete code examples
4. **How to Regenerate**: Analysis phase ‚Üí Implementation phase ‚Üí Patch generation ‚Üí Testing
5. **Validation Checklist**: How to verify patch applies cleanly and works correctly

This approach ensures patches can be maintained across OpenCode version changes without losing their purpose.

---

**Maintainer:** 524c  
**License:** MIT
